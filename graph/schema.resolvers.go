package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"rangoapp/database"
	"rangoapp/graph/model"
	"rangoapp/services"
	"rangoapp/utils"
	"rangoapp/validators"
	"time"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, phone string, password string) (*model.AuthResponse, error) {
	if err := validators.ValidateLoginInput(phone, password); err != nil {
		return nil, err
	}
	authService := services.NewAuthService(r.DB)
	response, err := authService.Login(ctx, phone, password)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		AccessToken:  response.AccessToken,
		RefreshToken: response.RefreshToken,
		User:         convertUserToGraphQL(response.User),
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	if err := validators.ValidateRegisterInput(&input); err != nil {
		return nil, err
	}
	authService := services.NewAuthService(r.DB)
	registerInput := services.RegisterInput{
		Password: input.Password,
		Name:     input.Name,
		Phone:    input.Phone,
	}

	response, err := authService.Register(ctx, registerInput)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		AccessToken:  response.AccessToken,
		RefreshToken: response.RefreshToken,
		User:         convertUserToGraphQL(response.User),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// JWT is stateless, so logout is just a success response
	// Client should remove the token
	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	if err := validators.ValidateCreateUserInput(&input); err != nil {
		return nil, err
	}
	// Get current user from context
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can create users
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can create users")
	}

	// Check subscription limits
	err = r.DB.CheckSubscriptionLimits(currentUser.CompanyID.Hex(), "create_user")
	if err != nil {
		return nil, err
	}

	var storeIDs []primitive.ObjectID
	var assignedStoreID *primitive.ObjectID

	if input.Role == "Admin" {
		// Admin gets all stores of the company
		stores, err := r.DB.FindStoresByCompanyID(currentUser.CompanyID.Hex())
		if err != nil {
			return nil, err
		}
		for _, store := range stores {
			storeIDs = append(storeIDs, store.ID)
		}
	} else if input.Role == "User" {
		// User gets assigned to a specific store
		if input.StoreID != nil {
			storeID, err := primitive.ObjectIDFromHex(*input.StoreID)
			if err != nil {
				return nil, gqlerror.Errorf("Invalid store ID")
			}
			// Verify store belongs to company
			hasAccess, err := r.DB.VerifyStoreAccess(*input.StoreID, currentUser.CompanyID.Hex())
			if err != nil || !hasAccess {
				return nil, gqlerror.Errorf("Store does not belong to your company")
			}
			storeIDs = []primitive.ObjectID{storeID}
			assignedStoreID = &storeID
		}
	}

	user, err := r.DB.CreateUser(
		input.Name,
		input.Phone,
		"", // Email removed from schema
		input.Password,
		input.Role,
		currentUser.CompanyID,
		storeIDs,
		assignedStoreID,
	)
	if err != nil {
		return nil, err
	}

	return convertUserToGraphQL(user), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	if err := validators.ValidateObjectID(id, "User ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateUpdateUserInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can update users
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can update users")
	}

	var assignedStoreID *primitive.ObjectID
	if input.StoreID != nil {
		storeID, err := primitive.ObjectIDFromHex(*input.StoreID)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid store ID")
		}
		assignedStoreID = &storeID
	}

	user, err := r.DB.UpdateUser(
		id,
		input.Name,
		input.Phone,
		nil, // Email removed from schema
		input.Role,
		assignedStoreID,
	)
	if err != nil {
		return nil, err
	}

	return convertUserToGraphQL(user), nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can delete users
	if currentUser.Role != "Admin" {
		return false, gqlerror.Errorf("Only Admin can delete users")
	}

	err = r.DB.DeleteUser(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// BlockUser is the resolver for the blockUser field.
func (r *mutationResolver) BlockUser(ctx context.Context, id string) (*model.User, error) {
	if err := validators.ValidateObjectID(id, "User ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can block users
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can block users")
	}

	user, err := r.DB.BlockUser(id)
	if err != nil {
		return nil, err
	}

	return convertUserToGraphQL(user), nil
}

// UnblockUser is the resolver for the unblockUser field.
func (r *mutationResolver) UnblockUser(ctx context.Context, id string) (*model.User, error) {
	if err := validators.ValidateObjectID(id, "User ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can unblock users
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can unblock users")
	}

	user, err := r.DB.UnblockUser(id)
	if err != nil {
		return nil, err
	}

	return convertUserToGraphQL(user), nil
}

// AssignUserToStore is the resolver for the assignUserToStore field.
func (r *mutationResolver) AssignUserToStore(ctx context.Context, userID string, storeID string) (*model.User, error) {
	if err := validators.ValidateObjectID(userID, "User ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateObjectID(storeID, "Store ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can assign users to stores
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can assign users to stores")
	}

	storeObjectID, err := primitive.ObjectIDFromHex(storeID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	user, err := r.DB.AssignUserToStore(userID, storeObjectID)
	if err != nil {
		return nil, err
	}

	return convertUserToGraphQL(user), nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePasswordInput) (bool, error) {
	if err := validators.ValidateChangePasswordInput(&input); err != nil {
		return false, err
	}

	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Users can only change their own password
	err = r.DB.ChangePassword(currentUser.ID.Hex(), input.CurrentPassword, input.NewPassword)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input model.CreateCompanyInput) (*model.Company, error) {
	if err := validators.ValidateCreateCompanyInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Check if user already has a company
	if currentUser.CompanyID != primitive.NilObjectID {
		return nil, gqlerror.Errorf("User already has a company. Use updateCompany to modify it.")
	}

	// Create company
	company, err := r.DB.CreateCompany(
		input.Name,
		input.Address,
		input.Phone,
		input.Description,
		input.Type,
		input.Email,
		input.Logo,
		input.Rccm,
		input.IDNat,
		input.IDCommerce,
	)
	if err != nil {
		return nil, err
	}

	// Create trial subscription automatically
	_, err = r.DB.CreateTrialSubscription(company.ID)
	if err != nil {
		utils.LogError(err, "Error creating trial subscription")
		// Continue anyway, subscription can be created later
	}

	// Update user's company ID
	err = r.DB.UpdateUserCompanyID(currentUser.ID.Hex(), company.ID)
	if err != nil {
		utils.LogError(err, "Error updating user company ID")
		return nil, gqlerror.Errorf("Error associating company with user")
	}

	return convertCompanyToGraphQL(company, r.DB, true), nil
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, input model.UpdateCompanyInput) (*model.Company, error) {
	if err := validators.ValidateUpdateCompanyInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can update company
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can update company")
	}

	company, err := r.DB.UpdateCompany(
		currentUser.CompanyID.Hex(),
		input.Name,
		input.Address,
		input.Phone,
		input.Email,
		input.Description,
		input.Type,
		input.Logo,
		input.Rccm,
		input.IDNat,
		input.IDCommerce,
	)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company, r.DB, true), nil
}

// DeleteCompany is the resolver for the deleteCompany field.
func (r *mutationResolver) DeleteCompany(ctx context.Context) (bool, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can delete company
	if currentUser.Role != "Admin" {
		return false, gqlerror.Errorf("Only Admin can delete company")
	}

	// Check if user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return false, gqlerror.Errorf("User does not have a company to delete")
	}

	// Delete company
	err = r.DB.DeleteCompany(currentUser.CompanyID.Hex())
	if err != nil {
		return false, err
	}

	// Update user's company ID to NilObjectID
	err = r.DB.UpdateUserCompanyID(currentUser.ID.Hex(), primitive.NilObjectID)
	if err != nil {
		utils.LogError(err, "Error updating user company ID after deletion")
		// Don't fail the deletion, just log the error
	}

	return true, nil
}

// UpdateExchangeRates is the resolver for the updateExchangeRates field.
func (r *mutationResolver) UpdateExchangeRates(ctx context.Context, rates []*model.ExchangeRateInput) (*model.Company, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can update exchange rates
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can update exchange rates")
	}

	// Verify that the user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return nil, gqlerror.Errorf("You must be associated with a company to update exchange rates")
	}

	// Validate input
	if len(rates) == 0 {
		return nil, gqlerror.Errorf("At least one exchange rate is required")
	}

	// Convert model.ExchangeRateInput to database.ExchangeRate
	dbRates := make([]database.ExchangeRate, len(rates))
	for i, rate := range rates {
		dbRates[i] = database.ExchangeRate{
			FromCurrency: rate.FromCurrency,
			ToCurrency:   rate.ToCurrency,
			Rate:         rate.Rate,
		}
	}

	// Update exchange rates
	company, err := r.DB.UpdateExchangeRates(currentUser.CompanyID.Hex(), currentUser.ID.Hex(), dbRates)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company, r.DB, true), nil
}

// CreateStore is the resolver for the createStore field.
func (r *mutationResolver) CreateStore(ctx context.Context, input model.CreateStoreInput) (*model.Store, error) {
	if err := validators.ValidateCreateStoreInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can create stores
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can create stores")
	}

	// Verify that the user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return nil, gqlerror.Errorf("You must be associated with a company to create stores")
	}

	// Check subscription limits
	err = r.DB.CheckSubscriptionLimits(currentUser.CompanyID.Hex(), "create_store")
	if err != nil {
		return nil, err
	}

	// Set default currency if not provided
	defaultCurrency := "USD"
	if input.DefaultCurrency != nil {
		defaultCurrency = *input.DefaultCurrency
	}

	// Set supported currencies
	var supportedCurrencies []string
	if input.SupportedCurrencies != nil && len(input.SupportedCurrencies) > 0 {
		supportedCurrencies = input.SupportedCurrencies
	}

	// Create store with the user's company ID
	store, err := r.DB.CreateStore(
		input.Name,
		input.Address,
		input.Phone,
		currentUser.CompanyID, // Use company ID from current user
		defaultCurrency,
		supportedCurrencies,
	)
	if err != nil {
		return nil, err
	}

	// Update all Admin users' storeIDs
	admins, err := r.DB.FindUsersByCompanyID(currentUser.CompanyID.Hex())
	if err == nil {
		for _, admin := range admins {
			if admin.Role == "Admin" {
				stores, _ := r.DB.FindStoresByCompanyID(currentUser.CompanyID.Hex())
				var storeIDs []primitive.ObjectID
				for _, s := range stores {
					storeIDs = append(storeIDs, s.ID)
				}
				r.DB.UpdateUserStoreIDs(admin.ID.Hex(), storeIDs)
			}
		}
	}

	return convertStoreToGraphQL(store, r.DB, true), nil
}

// UpdateStore is the resolver for the updateStore field.
func (r *mutationResolver) UpdateStore(ctx context.Context, id string, input model.UpdateStoreInput) (*model.Store, error) {
	if err := validators.ValidateObjectID(id, "Store ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateUpdateStoreInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can update stores
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can update stores")
	}

	// Verify store access
	hasAccess, err := r.DB.VerifyStoreAccess(id, currentUser.CompanyID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("Store does not belong to your company")
	}

	var defaultCurrency *string
	if input.DefaultCurrency != nil {
		defaultCurrency = input.DefaultCurrency
	}

	var supportedCurrencies *[]string
	if input.SupportedCurrencies != nil {
		supportedCurrencies = &input.SupportedCurrencies
	}

	store, err := r.DB.UpdateStore(id, input.Name, input.Address, input.Phone, defaultCurrency, supportedCurrencies)
	if err != nil {
		return nil, err
	}

	return convertStoreToGraphQL(store, r.DB, true), nil
}

// DeleteStore is the resolver for the deleteStore field.
func (r *mutationResolver) DeleteStore(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "Store ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can delete stores
	if currentUser.Role != "Admin" {
		return false, gqlerror.Errorf("Only Admin can delete stores")
	}

	// Verify store access
	hasAccess, err := r.DB.VerifyStoreAccess(id, currentUser.CompanyID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("Store does not belong to your company")
	}

	err = r.DB.DeleteStore(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	if err := validators.ValidateCreateProductInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	product, err := r.DB.CreateProduct(
		input.Name,
		input.Mark,
		storeID,
	)
	if err != nil {
		return nil, err
	}

	return convertProductToGraphQL(product, r.DB), nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.UpdateProductInput) (*model.Product, error) {
	if err := validators.ValidateObjectID(id, "Product ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateUpdateProductInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get product to verify store access
	product, err := r.DB.FindProductByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, product.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this product's store")
	}

	updatedProduct, err := r.DB.UpdateProduct(
		id,
		input.Name,
		input.Mark,
	)
	if err != nil {
		return nil, err
	}

	return convertProductToGraphQL(updatedProduct, r.DB), nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "Product ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Get product to verify store access
	product, err := r.DB.FindProductByID(id)
	if err != nil {
		return false, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, product.StoreID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("You don't have access to this product's store")
	}

	err = r.DB.DeleteProduct(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// SupplyStock is the resolver for the supplyStock field.
func (r *mutationResolver) SupplyStock(ctx context.Context, input model.StockSupplyInput) (*model.StockSupply, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Validate input
	if err := validators.ValidateObjectID(input.ProductID, "Product ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateObjectID(input.StoreID, "Store ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateObjectID(input.ProviderID, "Provider ID"); err != nil {
		return nil, err
	}
	if input.Quantity <= 0 {
		return nil, gqlerror.Errorf("Quantity must be greater than 0")
	}
	if input.PriceAchat <= 0 {
		return nil, gqlerror.Errorf("Price d'achat must be greater than 0")
	}
	if input.PriceVente < input.PriceAchat {
		return nil, gqlerror.Errorf("Price de vente must be >= price d'achat")
	}
	if input.PaymentType != "cash" && input.PaymentType != "debt" {
		return nil, gqlerror.Errorf("Payment type must be 'cash' or 'debt'")
	}
	if input.PaymentType == "debt" && (input.AmountPaid == nil || *input.AmountPaid < 0) {
		return nil, gqlerror.Errorf("Amount paid is required when payment type is 'debt'")
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	// Convert IDs
	productID, _ := primitive.ObjectIDFromHex(input.ProductID)
	storeID, _ := primitive.ObjectIDFromHex(input.StoreID)
	providerID, _ := primitive.ObjectIDFromHex(input.ProviderID)
	operatorID := currentUser.ID

	// Determine currency
	currency := ""
	if input.Currency != nil && *input.Currency != "" {
		currency = *input.Currency
		isValid, err := r.DB.ValidateStoreCurrency(input.StoreID, currency)
		if err != nil {
			return nil, err
		}
		if !isValid {
			return nil, gqlerror.Errorf("Currency %s is not supported by this store", currency)
		}
	} else {
		defaultCurrency, err := r.DB.GetStoreDefaultCurrency(input.StoreID)
		if err != nil {
			return nil, err
		}
		currency = defaultCurrency
	}

	// Parse date
	date := time.Now()
	if input.Date != nil && *input.Date != "" {
		parsedDate, err := time.Parse(time.RFC3339, *input.Date)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid date format")
		}
		date = parsedDate
	}

	// Create or update ProductInStock
	productInStock, err := r.DB.CreateProductInStock(
		productID,
		input.PriceVente,
		input.PriceAchat,
		input.Quantity,
		currency,
		storeID,
		providerID,
	)
	if err != nil {
		return nil, err
	}

	// Calculate total amount and debt
	totalAmount := input.PriceAchat * input.Quantity
	amountPaid := 0.0
	if input.PaymentType == "cash" {
		amountPaid = totalAmount
	} else if input.AmountPaid != nil {
		amountPaid = *input.AmountPaid
	}
	amountDue := totalAmount - amountPaid

	// Create stock supply first (without debt ID for now)
	supply, err := r.DB.CreateStockSupply(
		productID,
		productInStock.ID,
		input.Quantity,
		input.PriceAchat,
		input.PriceVente,
		currency,
		storeID,
		providerID,
		operatorID,
		input.PaymentType,
		nil, // Will be set after creating debt
		date,
	)
	if err != nil {
		return nil, err
	}

	// Create provider debt if payment type is "debt" (now we have the supply ID)
	if input.PaymentType == "debt" && amountDue > 0 {
		_, err := r.DB.CreateProviderDebt(
			supply.ID,
			providerID,
			storeID,
			totalAmount,
			amountPaid,
			amountDue,
			currency,
		)
		if err != nil {
			return nil, err
		}
		// Note: providerDebt is created but not currently linked to supply

		// Update supply with debt ID
		// Note: We would need an UpdateStockSupply function, but for now the debt reference is enough
		// The supply can be queried with the debt ID from the debt side
	}

	// Create stock movement (ENTREE)
	_, err = r.DB.CreateStockMovement(
		productInStock.ID.Hex(),
		input.StoreID,
		"ENTREE",
		input.Quantity,
		input.PriceAchat,
		currency,
		operatorID,
		fmt.Sprintf("Approvisionnement - Fournisseur: %s", input.ProviderID),
		fmt.Sprintf("supply-%s", supply.ID.Hex()),
		"SUPPLY",
		&supply.ID,
	)
	if err != nil {
		utils.LogError(err, "Error creating stock movement for supply")
	}

	// Create caisse transaction (SORTIE) if paid cash
	if input.PaymentType == "cash" {
		_, err = r.DB.CreateTrans(
			"Sortie",
			totalAmount,
			fmt.Sprintf("Achat stock - Produit: %s, Fournisseur: %s", input.ProductID, input.ProviderID),
			currency,
			operatorID,
			storeID,
			&date,
		)
		if err != nil {
			utils.LogError(err, "Error creating caisse transaction for supply")
		}
	}

	return convertStockSupplyToGraphQL(supply, r.DB), nil
}

// CreateClient is the resolver for the createClient field.
func (r *mutationResolver) CreateClient(ctx context.Context, input model.CreateClientInput) (*model.Client, error) {
	if err := validators.ValidateCreateClientInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	client, err := r.DB.CreateClient(input.Name, input.Phone, storeID, input.CreditLimit)
	if err != nil {
		return nil, err
	}

	return convertClientToGraphQL(client, r.DB), nil
}

// UpdateClient is the resolver for the updateClient field.
func (r *mutationResolver) UpdateClient(ctx context.Context, id string, input model.UpdateClientInput) (*model.Client, error) {
	if err := validators.ValidateObjectID(id, "Client ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateUpdateClientInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get client to verify store access
	client, err := r.DB.FindClientByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, client.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this client's store")
	}

	updatedClient, err := r.DB.UpdateClient(id, input.Name, input.Phone, input.CreditLimit)
	if err != nil {
		return nil, err
	}

	return convertClientToGraphQL(updatedClient, r.DB), nil
}

// DeleteClient is the resolver for the deleteClient field.
func (r *mutationResolver) DeleteClient(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "Client ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Get client to verify store access
	client, err := r.DB.FindClientByID(id)
	if err != nil {
		return false, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, client.StoreID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("You don't have access to this client's store")
	}

	err = r.DB.DeleteClient(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateClientCreditLimit is the resolver for the updateClientCreditLimit field.
func (r *mutationResolver) UpdateClientCreditLimit(ctx context.Context, clientID string, creditLimit float64) (*model.Client, error) {
	if err := validators.ValidateObjectID(clientID, "Client ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Seuls les admins peuvent modifier les limites de crédit
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only admins can update credit limits")
	}

	// Get client to verify store access
	client, err := r.DB.FindClientByID(clientID)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, client.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this client's store")
	}

	// Valider que la limite est positive
	if creditLimit < 0 {
		return nil, gqlerror.Errorf("Credit limit cannot be negative")
	}

	// Mettre à jour la limite de crédit
	updatedClient, err := r.DB.UpdateClientCreditLimit(clientID, creditLimit)
	if err != nil {
		return nil, err
	}

	return convertClientToGraphQL(updatedClient, r.DB), nil
}

// CreateProvider is the resolver for the createProvider field.
func (r *mutationResolver) CreateProvider(ctx context.Context, input model.CreateProviderInput) (*model.Provider, error) {
	if err := validators.ValidateCreateProviderInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	provider, err := r.DB.CreateProvider(input.Name, input.Phone, input.Address, storeID)
	if err != nil {
		return nil, err
	}

	return convertProviderToGraphQL(provider, r.DB), nil
}

// UpdateProvider is the resolver for the updateProvider field.
func (r *mutationResolver) UpdateProvider(ctx context.Context, id string, input model.UpdateProviderInput) (*model.Provider, error) {
	if err := validators.ValidateObjectID(id, "Provider ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateUpdateProviderInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get provider to verify store access
	provider, err := r.DB.FindProviderByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, provider.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this provider's store")
	}

	updatedProvider, err := r.DB.UpdateProvider(id, input.Name, input.Phone, input.Address)
	if err != nil {
		return nil, err
	}

	return convertProviderToGraphQL(updatedProvider, r.DB), nil
}

// DeleteProvider is the resolver for the deleteProvider field.
func (r *mutationResolver) DeleteProvider(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "Provider ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Get provider to verify store access
	provider, err := r.DB.FindProviderByID(id)
	if err != nil {
		return false, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, provider.StoreID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("You don't have access to this provider's store")
	}

	err = r.DB.DeleteProvider(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateFacture is the resolver for the createFacture field.
func (r *mutationResolver) CreateFacture(ctx context.Context, input model.CreateFactureInput) (*model.Facture, error) {
	if err := validators.ValidateCreateFactureInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	clientID, err := primitive.ObjectIDFromHex(input.ClientID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid client ID")
	}

	// Parse date
	date, err := time.Parse(time.RFC3339, input.Date)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid date format")
	}

	// Convert products
	var factureProducts []database.FactureProduct
	for _, p := range input.Products {
		productID, err := primitive.ObjectIDFromHex(p.ProductID)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid product ID: %s", p.ProductID)
		}

		// Verify product belongs to store
		product, err := r.DB.FindProductByID(p.ProductID)
		if err != nil {
			return nil, gqlerror.Errorf("Product not found: %s", p.ProductID)
		}
		if product.StoreID != storeID {
			return nil, gqlerror.Errorf("Product %s does not belong to store", p.ProductID)
		}

		// Note: Factures use Product templates, not ProductInStock
		// Stock checking is not applicable for factures as they are just invoices
		// The actual stock management is done through ProductInStock

		factureProducts = append(factureProducts, database.FactureProduct{
			ProductID: productID,
			Quantity:  p.Quantity,
			Price:     p.Price,
		})

		// Note: Stock updates are no longer done here since Product is now just a template
	}

	// Determine currency: use provided currency or default from store
	currency := ""
	if input.Currency != nil && *input.Currency != "" {
		currency = *input.Currency
		// Validate currency is supported by store
		isValid, err := r.DB.ValidateStoreCurrency(input.StoreID, currency)
		if err != nil {
			return nil, err
		}
		if !isValid {
			return nil, gqlerror.Errorf("Currency %s is not supported by this store. Supported currencies: %v", currency, func() []string {
				store, _ := r.DB.FindStoreByID(input.StoreID)
				if store != nil {
					return store.SupportedCurrencies
				}
				return []string{}
			}())
		}
	} else {
		// Use default currency from store
		defaultCurrency, err := r.DB.GetStoreDefaultCurrency(input.StoreID)
		if err != nil {
			return nil, err
		}
		currency = defaultCurrency
	}

	// Create facture
	facture := &database.Facture{
		ID:        primitive.NewObjectID(),
		Products:  factureProducts,
		Quantity:  input.Quantity,
		Date:      date,
		Price:     input.Price,
		Currency:  currency,
		ClientID:  clientID,
		StoreID:   storeID,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	createdFacture, err := r.DB.CreateFacture(facture)
	if err != nil {
		return nil, err
	}

	// Automatically create an "Entree" (entry) transaction in caisse when a facture is created
	// This represents money coming in from the sale
	_, err = r.DB.CreateTrans(
		"Entree",
		input.Price,
		fmt.Sprintf("Vente facture %s", createdFacture.FactureNumber),
		currency,
		currentUser.ID,
		storeID,
		&date,
	)
	if err != nil {
		// Log error but don't fail the facture creation
		utils.LogError(err, "Error creating caisse transaction for facture")
	}

	return convertFactureToGraphQL(createdFacture, r.DB), nil
}

// UpdateFacture is the resolver for the updateFacture field.
func (r *mutationResolver) UpdateFacture(ctx context.Context, id string, input model.UpdateFactureInput) (*model.Facture, error) {
	if err := validators.ValidateObjectID(id, "Facture ID"); err != nil {
		return nil, err
	}
	if err := validators.ValidateUpdateFactureInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get facture to verify store access
	facture, err := r.DB.FindFactureByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, facture.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this facture's store")
	}

	var factureProducts []database.FactureProduct
	if input.Products != nil {
		for _, p := range input.Products {
			productID, err := primitive.ObjectIDFromHex(p.ProductID)
			if err != nil {
				return nil, gqlerror.Errorf("Invalid product ID")
			}
			factureProducts = append(factureProducts, database.FactureProduct{
				ProductID: productID,
				Quantity:  p.Quantity,
				Price:     p.Price,
			})
		}
	}

	var clientID *primitive.ObjectID
	if input.ClientID != nil {
		id, err := primitive.ObjectIDFromHex(*input.ClientID)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid client ID")
		}
		clientID = &id
	}

	var factureDate *time.Time
	if input.Date != nil {
		date, err := time.Parse(time.RFC3339, *input.Date)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid date format")
		}
		factureDate = &date
	}

	var quantity *int
	if input.Quantity != nil {
		quantity = input.Quantity
	}

	updatedFacture, err := r.DB.UpdateFacture(
		id,
		factureProducts,
		clientID,
		quantity,
		input.Price,
		input.Currency,
		factureDate,
	)
	if err != nil {
		return nil, err
	}

	return convertFactureToGraphQL(updatedFacture, r.DB), nil
}

// DeleteFacture is the resolver for the deleteFacture field.
func (r *mutationResolver) DeleteFacture(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "Facture ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Get facture to verify store access
	facture, err := r.DB.FindFactureByID(id)
	if err != nil {
		return false, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, facture.StoreID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("You don't have access to this facture's store")
	}

	err = r.DB.DeleteFacture(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateRapportStore is the resolver for the createRapportStore field.
func (r *mutationResolver) CreateRapportStore(ctx context.Context, input model.CreateRapportStoreInput) (*model.RapportStore, error) {
	if err := validators.ValidateCreateRapportStoreInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	productID, err := primitive.ObjectIDFromHex(input.ProductID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid product ID")
	}

	// Verify product belongs to store
	product, err := r.DB.FindProductByID(input.ProductID)
	if err != nil {
		return nil, err
	}
	if product.StoreID != storeID {
		return nil, gqlerror.Errorf("Product does not belong to store")
	}

	// Parse date
	date, err := time.Parse(time.RFC3339, input.Date)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid date format")
	}

	// Validate type
	if input.Type != "entree" && input.Type != "sortie" {
		return nil, gqlerror.Errorf("Type must be 'entree' or 'sortie'")
	}

	rapport := &database.RapportStore{
		ID:        primitive.NewObjectID(),
		Type:      input.Type,
		ProductID: productID,
		Quantity:  input.Quantity,
		Date:      date,
		StoreID:   storeID,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	createdRapport, err := r.DB.CreateRapportStore(rapport)
	if err != nil {
		return nil, err
	}

	// Update product stock
	stockChange := input.Quantity
	if input.Type == "sortie" {
		stockChange = -input.Quantity
	}
	err = r.DB.UpdateProductStock(input.ProductID, stockChange)
	if err != nil {
		return nil, err
	}

	return convertRapportStoreToGraphQL(createdRapport, r.DB), nil
}

// DeleteRapportStore is the resolver for the deleteRapportStore field.
func (r *mutationResolver) DeleteRapportStore(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "RapportStore ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Get rapport to verify store access
	rapport, err := r.DB.FindRapportStoreByID(id)
	if err != nil {
		return false, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, rapport.StoreID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("You don't have access to this rapport's store")
	}

	err = r.DB.DeleteRapportStore(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateCaisseTransaction is the resolver for the createCaisseTransaction field.
func (r *mutationResolver) CreateCaisseTransaction(ctx context.Context, input model.CreateCaisseTransactionInput) (*model.CaisseTransaction, error) {
	if err := validators.ValidateCreateCaisseTransactionInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	operatorID := currentUser.ID

	// Parse date if provided
	var transactionDate *time.Time
	if input.Date != nil {
		date, err := time.Parse(time.RFC3339, *input.Date)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid date format")
		}
		transactionDate = &date
	}

	// Determine currency: use provided currency or default from store
	currency := ""
	if input.Currency != nil && *input.Currency != "" {
		currency = *input.Currency
		// Validate currency is supported by store
		isValid, err := r.DB.ValidateStoreCurrency(input.StoreID, currency)
		if err != nil {
			return nil, err
		}
		if !isValid {
			return nil, gqlerror.Errorf("Currency %s is not supported by this store. Supported currencies: %v", currency, func() []string {
				store, _ := r.DB.FindStoreByID(input.StoreID)
				if store != nil {
					return store.SupportedCurrencies
				}
				return []string{}
			}())
		}
	} else {
		// Use default currency from store
		defaultCurrency, err := r.DB.GetStoreDefaultCurrency(input.StoreID)
		if err != nil {
			return nil, err
		}
		currency = defaultCurrency
	}

	trans, err := r.DB.CreateTrans(
		input.Operation,
		input.Amount,
		input.Description,
		currency,
		operatorID,
		storeID,
		transactionDate,
	)
	if err != nil {
		return nil, err
	}

	return convertCaisseTransactionToGraphQL(trans, r.DB), nil
}

// DeleteCaisseTransaction is the resolver for the deleteCaisseTransaction field.
func (r *mutationResolver) DeleteCaisseTransaction(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "Transaction ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Verify transaction exists and user has access
	trans, err := r.DB.FindTransByID(id)
	if err != nil {
		return false, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, trans.StoreID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("You don't have access to this transaction's store")
	}

	err = r.DB.DeleteTrans(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateSale is the resolver for the createSale field.
func (r *mutationResolver) CreateSale(ctx context.Context, input model.CreateSaleInput) (*model.Sale, error) {
	if err := validators.ValidateCreateSaleInput(&input); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	// Client ID is optional (for walk-in sales)
	var clientID *primitive.ObjectID
	if input.ClientID != nil {
		id, err := primitive.ObjectIDFromHex(*input.ClientID)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid client ID")
		}
		clientID = &id
	}

	operatorID := currentUser.ID

	// Parse date if provided
	// Accept both RFC3339 format (2024-01-01T00:00:00Z) and HTML date input format (2024-01-01)
	var saleDate *time.Time
	if input.Date != nil {
		var date time.Time
		var err error
		// Try RFC3339 format first
		date, err = time.Parse(time.RFC3339, *input.Date)
		if err != nil {
			// Try HTML date input format (YYYY-MM-DD)
			date, err = time.Parse("2006-01-02", *input.Date)
			if err != nil {
				return nil, gqlerror.Errorf("Invalid date format. Expected RFC3339 (e.g., 2024-01-01T00:00:00Z) or date format (e.g., 2024-01-01)")
			}
			// Set time to start of day (00:00:00) in local timezone
			date = time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, time.Local)
		}
		saleDate = &date
	}

	// Convert basket products
	var basket []database.ProductInBasket
	for _, p := range input.Basket {
		productInStockID, err := primitive.ObjectIDFromHex(p.ProductInStockID)
		if err != nil {
			return nil, gqlerror.Errorf("Invalid product in stock ID: %s", p.ProductInStockID)
		}

		// Verify product in stock belongs to store
		productInStock, err := r.DB.FindProductInStockByID(p.ProductInStockID)
		if err != nil {
			return nil, gqlerror.Errorf("Product in stock not found: %s", p.ProductInStockID)
		}
		if productInStock.StoreID != storeID {
			return nil, gqlerror.Errorf("Product in stock %s does not belong to store", p.ProductInStockID)
		}

		basket = append(basket, database.ProductInBasket{
			ProductInStockID: productInStockID,
			Quantity:         p.Quantity,
			Price:            p.Price,
		})
	}

	// Determine currency: use provided currency or default from store
	currency := ""
	if input.Currency != nil && *input.Currency != "" {
		currency = *input.Currency
		// Validate currency is supported by store
		isValid, err := r.DB.ValidateStoreCurrency(input.StoreID, currency)
		if err != nil {
			return nil, err
		}
		if !isValid {
			return nil, gqlerror.Errorf("Currency %s is not supported by this store. Supported currencies: %v", currency, func() []string {
				store, _ := r.DB.FindStoreByID(input.StoreID)
				if store != nil {
					return store.SupportedCurrencies
				}
				return []string{}
			}())
		}
	} else {
		// Use default currency from store
		defaultCurrency, err := r.DB.GetStoreDefaultCurrency(input.StoreID)
		if err != nil {
			return nil, err
		}
		currency = defaultCurrency
	}

	// Determine payment type
	paymentType := "cash"
	if input.PaymentType != nil && *input.PaymentType != "" {
		paymentType = *input.PaymentType
	}

	// Create sale (this will automatically update stock and create caisse transaction)
	sale, err := r.DB.CreateSale(
		basket,
		input.PriceToPay,
		input.PricePayed,
		currency,
		paymentType,
		clientID,
		operatorID,
		storeID,
		saleDate,
	)
	if err != nil {
		return nil, err
	}

	return convertSaleToGraphQL(sale, r.DB), nil
}

// DeleteSale is the resolver for the deleteSale field.
func (r *mutationResolver) DeleteSale(ctx context.Context, id string) (bool, error) {
	if err := validators.ValidateObjectID(id, "Sale ID"); err != nil {
		return false, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	// Verify sale exists and user has access
	sale, err := r.DB.FindSaleByID(id)
	if err != nil {
		return false, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, sale.StoreID.Hex())
	if err != nil || !hasAccess {
		return false, gqlerror.Errorf("You don't have access to this sale's store")
	}

	err = r.DB.DeleteSale(id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateFactureFromSale is the resolver for the createFactureFromSale field.
func (r *mutationResolver) CreateFactureFromSale(ctx context.Context, saleID string) (*model.Facture, error) {
	if err := validators.ValidateObjectID(saleID, "Sale ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get sale
	sale, err := r.DB.FindSaleByID(saleID)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, sale.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this sale's store")
	}

	// Convert sale basket to facture products
	var factureProducts []database.FactureProduct
	var totalQuantity int
	for _, item := range sale.Basket {
		// Note: FactureProduct still uses ProductID, we need to get it from ProductInStock
		productInStock, err := r.DB.FindProductInStockByID(item.ProductInStockID.Hex())
		if err != nil {
			return nil, gqlerror.Errorf("Product in stock not found: %s", item.ProductInStockID.Hex())
		}
		factureProducts = append(factureProducts, database.FactureProduct{
			ProductID: productInStock.ProductID,
			Quantity:  int(item.Quantity),
			Price:     item.Price,
		})
		totalQuantity += int(item.Quantity)
	}

	// Create facture from sale
	// Note: If sale has no client, we still need a clientID for Facture
	// For now, we'll require a client to create a facture
	if sale.ClientID == nil {
		return nil, gqlerror.Errorf("Cannot create facture from sale without a client. Please specify a client when creating the sale.")
	}

	facture := &database.Facture{
		ID:        primitive.NewObjectID(),
		Products:  factureProducts,
		Quantity:  totalQuantity,
		Date:      sale.Date,
		Price:     sale.PriceToPay,
		Currency:  sale.Currency,
		ClientID:  *sale.ClientID,
		StoreID:   sale.StoreID,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	createdFacture, err := r.DB.CreateFacture(facture)
	if err != nil {
		return nil, err
	}

	// Note: We don't create another caisse transaction because the sale already created one
	// The facture is just a formal document for printing

	return convertFactureToGraphQL(createdFacture, r.DB), nil
}

// PayDebt is the resolver for the payDebt field.
func (r *mutationResolver) PayDebt(ctx context.Context, debtID string, amount float64, description string) (*model.Debt, error) {
	if err := validators.ValidateObjectID(debtID, "Debt ID"); err != nil {
		return nil, err
	}
	if amount <= 0 {
		return nil, gqlerror.Errorf("Payment amount must be greater than 0")
	}
	if description == "" {
		return nil, gqlerror.Errorf("Description is required")
	}

	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get debt to verify store access
	debt, err := r.DB.GetDebtByID(debtID)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, debt.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this debt's store")
	}

	// Pay debt
	updatedDebt, _, err := r.DB.PayDebt(debtID, amount, currentUser.ID, debt.StoreID, description)
	if err != nil {
		return nil, err
	}

	return convertDebtToGraphQL(updatedDebt, r.DB), nil
}

// PayProviderDebt is the resolver for the payProviderDebt field.
func (r *mutationResolver) PayProviderDebt(ctx context.Context, providerDebtID string, amount float64, description string) (*model.ProviderDebt, error) {
	if err := validators.ValidateObjectID(providerDebtID, "Provider Debt ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get provider debt to verify store access
	debt, err := r.DB.GetProviderDebtByID(providerDebtID)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, debt.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this provider debt's store")
	}

	// Pay the debt
	updatedDebt, payment, err := r.DB.PayProviderDebt(
		providerDebtID,
		amount,
		currentUser.ID,
		debt.StoreID,
		description,
	)
	if err != nil {
		return nil, err
	}

	// Log payment creation (payment is already created in PayProviderDebt)
	_ = payment

	return convertProviderDebtToGraphQL(updatedDebt, r.DB), nil
}

// CreateInventory is the resolver for the createInventory field.
func (r *mutationResolver) CreateInventory(ctx context.Context, input model.CreateInventoryInput) (*model.Inventory, error) {
	if err := validators.ValidateCreateInventoryInput(&input); err != nil {
		return nil, err
	}

	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Vérifier l'abonnement
	if err := r.CheckSubscription(ctx); err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, input.StoreID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	storeID, err := primitive.ObjectIDFromHex(input.StoreID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid store ID")
	}

	// Check if there's already an active inventory for this store
	activeInventory, err := r.DB.GetActiveInventory(input.StoreID)
	if err != nil {
		return nil, err
	}
	if activeInventory != nil {
		return nil, gqlerror.Errorf("There is already an active inventory for this store. Please complete or cancel it first.")
	}

	inventory, err := r.DB.CreateInventory(storeID, currentUser.ID, input.Description)
	if err != nil {
		return nil, err
	}

	return convertInventoryToGraphQL(inventory, r.DB), nil
}

// AddInventoryItem is the resolver for the addInventoryItem field.
func (r *mutationResolver) AddInventoryItem(ctx context.Context, input model.AddInventoryItemInput) (*model.Inventory, error) {
	if err := validators.ValidateAddInventoryItemInput(&input); err != nil {
		return nil, err
	}

	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get inventory to verify access
	inventory, err := r.DB.GetInventoryByID(input.InventoryID)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, inventory.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this inventory's store")
	}

	productID, err := primitive.ObjectIDFromHex(input.ProductID)
	if err != nil {
		return nil, gqlerror.Errorf("Invalid product ID")
	}

	reason := ""
	if input.Reason != nil {
		reason = *input.Reason
	}

	updatedInventory, err := r.DB.AddInventoryItem(input.InventoryID, productID, input.PhysicalQuantity, reason, currentUser.ID)
	if err != nil {
		return nil, err
	}

	return convertInventoryToGraphQL(updatedInventory, r.DB), nil
}

// CompleteInventory is the resolver for the completeInventory field.
func (r *mutationResolver) CompleteInventory(ctx context.Context, inventoryID string, adjustStock bool) (*model.Inventory, error) {
	if err := validators.ValidateObjectID(inventoryID, "Inventory ID"); err != nil {
		return nil, err
	}

	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get inventory to verify access
	inventory, err := r.DB.GetInventoryByID(inventoryID)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, inventory.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this inventory's store")
	}

	completedInventory, err := r.DB.CompleteInventory(inventoryID, adjustStock)
	if err != nil {
		return nil, err
	}

	return convertInventoryToGraphQL(completedInventory, r.DB), nil
}

// CancelInventory is the resolver for the cancelInventory field.
func (r *mutationResolver) CancelInventory(ctx context.Context, inventoryID string) (*model.Inventory, error) {
	if err := validators.ValidateObjectID(inventoryID, "Inventory ID"); err != nil {
		return nil, err
	}

	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Get inventory to verify access
	inventory, err := r.DB.GetInventoryByID(inventoryID)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, inventory.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this inventory's store")
	}

	cancelledInventory, err := r.DB.CancelInventory(inventoryID)
	if err != nil {
		return nil, err
	}

	return convertInventoryToGraphQL(cancelledInventory, r.DB), nil
}

// CreateSubscription is the resolver for the createSubscription field.
func (r *mutationResolver) CreateSubscription(ctx context.Context, plan string, paymentMethod string, paymentID string) (*model.CompanySubscription, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	if currentUser.CompanyID == primitive.NilObjectID {
		return nil, gqlerror.Errorf("User does not have a company yet")
	}

	// Only Admin can create subscriptions
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can create subscriptions")
	}

	subscription, err := r.DB.CreateSubscription(currentUser.CompanyID.Hex(), plan, paymentMethod, paymentID)
	if err != nil {
		return nil, err
	}

	sub := convertSubscriptionToGraphQL(subscription)
	return sub, nil
}

// UpgradeSubscription is the resolver for the upgradeSubscription field.
func (r *mutationResolver) UpgradeSubscription(ctx context.Context, plan string, paymentMethod string, paymentID string) (*model.CompanySubscription, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	if currentUser.CompanyID == primitive.NilObjectID {
		return nil, gqlerror.Errorf("User does not have a company yet")
	}

	// Only Admin can upgrade subscriptions
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can upgrade subscriptions")
	}

	subscription, err := r.DB.UpgradeSubscription(currentUser.CompanyID.Hex(), plan, paymentMethod, paymentID)
	if err != nil {
		return nil, err
	}

	sub := convertSubscriptionToGraphQL(subscription)
	return sub, nil
}

// CancelSubscription is the resolver for the cancelSubscription field.
func (r *mutationResolver) CancelSubscription(ctx context.Context) (bool, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, gqlerror.Errorf("Unauthorized")
	}

	if currentUser.CompanyID == primitive.NilObjectID {
		return false, gqlerror.Errorf("User does not have a company yet")
	}

	// Only Admin can cancel subscriptions
	if currentUser.Role != "Admin" {
		return false, gqlerror.Errorf("Only Admin can cancel subscriptions")
	}

	err = r.DB.CancelSubscription(currentUser.CompanyID.Hex())
	if err != nil {
		return false, err
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := r.GetUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	return convertUserToGraphQL(user), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Only Admin can see all users
	if currentUser.Role != "Admin" {
		return nil, gqlerror.Errorf("Only Admin can view all users")
	}

	// Check if user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return []*model.User{}, nil // Return empty list if no company
	}

	users, err := r.DB.FindUsersByCompanyID(currentUser.CompanyID.Hex())
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, user := range users {
		result = append(result, convertUserToGraphQL(user))
	}

	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	if err := validators.ValidateObjectID(id, "User ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	user, err := r.DB.FindUserByID(id)
	if err != nil {
		return nil, err
	}

	// Verify user belongs to same company
	if user.CompanyID != currentUser.CompanyID {
		return nil, gqlerror.Errorf("User not found")
	}

	return convertUserToGraphQL(user), nil
}

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context) (*model.Company, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Check if user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return nil, gqlerror.Errorf("User does not have a company yet. Please create one using createCompany mutation.")
	}

	company, err := r.DB.FindCompanyByID(currentUser.CompanyID.Hex())
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company, r.DB, true), nil
}

// ExchangeRates is the resolver for the exchangeRates field.
func (r *queryResolver) ExchangeRates(ctx context.Context) ([]*model.ExchangeRate, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Verify that the user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return nil, gqlerror.Errorf("User does not have a company yet")
	}

	// Get exchange rates from database
	rates, err := r.DB.GetCompanyExchangeRates(currentUser.CompanyID.Hex())
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	var rateModels []*model.ExchangeRate
	for _, rate := range rates {
		rateModels = append(rateModels, convertExchangeRateToGraphQL(&rate))
	}

	return rateModels, nil
}

// ConvertCurrency is the resolver for the convertCurrency field.
func (r *queryResolver) ConvertCurrency(ctx context.Context, amount float64, fromCurrency string, toCurrency string) (float64, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return 0, gqlerror.Errorf("Unauthorized")
	}

	// Verify that the user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return 0, gqlerror.Errorf("User does not have a company yet")
	}

	// Validate amount
	if amount < 0 {
		return 0, gqlerror.Errorf("Amount must be positive")
	}

	// Convert currency using the company's exchange rates
	convertedAmount, err := r.DB.ConvertCurrency(currentUser.CompanyID.Hex(), amount, fromCurrency, toCurrency)
	if err != nil {
		return 0, err
	}

	return convertedAmount, nil
}

// Subscription is the resolver for the subscription field.
func (r *queryResolver) Subscription(ctx context.Context) (*model.CompanySubscription, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	if currentUser.CompanyID == primitive.NilObjectID {
		return nil, gqlerror.Errorf("User does not have a company yet")
	}

	subscription, err := r.DB.GetCompanySubscription(currentUser.CompanyID.Hex())
	if err != nil {
		return nil, err
	}

	sub := convertSubscriptionToGraphQL(subscription)
	return sub, nil
}

// CheckSubscriptionStatus is the resolver for the checkSubscriptionStatus field.
func (r *queryResolver) CheckSubscriptionStatus(ctx context.Context) (*model.SubscriptionStatus, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	if currentUser.CompanyID == primitive.NilObjectID {
		return &model.SubscriptionStatus{
			IsValid: false,
			Message: stringPtr("User does not have a company yet"),
		}, nil
	}

	subscriptionService := services.NewSubscriptionService(r.DB)
	err = subscriptionService.ValidateSubscription(ctx, currentUser.CompanyID.Hex())

	subscription, _ := r.DB.GetCompanySubscription(currentUser.CompanyID.Hex())
	var subModel *model.CompanySubscription
	if subscription != nil {
		subModel = convertSubscriptionToGraphQL(subscription)
	}

	if err != nil {
		return &model.SubscriptionStatus{
			IsValid:      false,
			Message:      stringPtr(err.Error()),
			Subscription: subModel,
		}, nil
	}

	return &model.SubscriptionStatus{
		IsValid:      true,
		Message:      nil,
		Subscription: subModel,
	}, nil
}

// SubscriptionPlans is the resolver for the subscriptionPlans field.
func (r *queryResolver) SubscriptionPlans(ctx context.Context) ([]*model.SubscriptionPlan, error) {
	plans, err := r.DB.GetAllSubscriptionPlans()
	if err != nil {
		return nil, err
	}

	var result []*model.SubscriptionPlan
	for _, plan := range plans {
		result = append(result, convertSubscriptionPlanToGraphQL(plan))
	}

	return result, nil
}

// SubscriptionPlan is the resolver for the subscriptionPlan field.
func (r *queryResolver) SubscriptionPlan(ctx context.Context, id string) (*model.SubscriptionPlan, error) {
	if id == "" {
		return nil, gqlerror.Errorf("Plan ID cannot be empty")
	}

	plan, err := r.DB.GetSubscriptionPlanByID(id)
	if err != nil {
		return nil, err
	}

	return convertSubscriptionPlanToGraphQL(plan), nil
}

// Stores is the resolver for the stores field.
func (r *queryResolver) Stores(ctx context.Context) ([]*model.Store, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Check if user has a company
	if currentUser.CompanyID == primitive.NilObjectID {
		return []*model.Store{}, nil // Return empty list if no company
	}

	var stores []*database.Store
	if currentUser.Role == "Admin" {
		stores, err = r.DB.FindStoresByCompanyID(currentUser.CompanyID.Hex())
	} else {
		// User can only see assigned store
		if currentUser.AssignedStoreID != nil {
			store, err := r.DB.FindStoreByID(currentUser.AssignedStoreID.Hex())
			if err == nil {
				stores = []*database.Store{store}
			}
		}
	}

	if err != nil {
		return nil, err
	}

	var result []*model.Store
	for _, store := range stores {
		result = append(result, convertStoreToGraphQL(store, r.DB, true))
	}

	return result, nil
}

// Store is the resolver for the store field.
func (r *queryResolver) Store(ctx context.Context, id string) (*model.Store, error) {
	if err := validators.ValidateObjectID(id, "Store ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, id)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	store, err := r.DB.FindStoreByID(id)
	if err != nil {
		return nil, err
	}

	return convertStoreToGraphQL(store, r.DB, true), nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, storeID *string) ([]*model.Product, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		// Verify access to specific store
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		// Get accessible stores
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	// Find all products in accessible stores (products are now just templates)
	products, err := r.DB.FindProductsByStoreIDs(storeIDs)
	if err != nil {
		return nil, err
	}

	var result []*model.Product
	for _, product := range products {
		result = append(result, convertProductToGraphQL(product, r.DB))
	}

	return result, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	if err := validators.ValidateObjectID(id, "Product ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	product, err := r.DB.FindProductByID(id)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, product.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this product's store")
	}

	return convertProductToGraphQL(product, r.DB), nil
}

// ProductsInStock is the resolver for the productsInStock field.
func (r *queryResolver) ProductsInStock(ctx context.Context, storeID *string, productID *string, providerID *string) ([]*model.ProductInStock, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	var productsInStock []*database.ProductInStock
	if productID != nil && *productID != "" {
		productsInStock, err = r.DB.FindProductsInStockByProductID(*productID, storeIDs)
	} else if providerID != nil && *providerID != "" {
		productsInStock, err = r.DB.FindProductsInStockByProviderID(*providerID, storeIDs)
	} else {
		productsInStock, err = r.DB.FindProductsInStockByStoreIDs(storeIDs)
	}
	if err != nil {
		return nil, err
	}

	var result []*model.ProductInStock
	for _, pis := range productsInStock {
		result = append(result, convertProductInStockToGraphQL(pis, r.DB))
	}

	return result, nil
}

// ProductInStock is the resolver for the productInStock field.
func (r *queryResolver) ProductInStock(ctx context.Context, id string) (*model.ProductInStock, error) {
	if err := validators.ValidateObjectID(id, "Product In Stock ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	productInStock, err := r.DB.FindProductInStockByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, productInStock.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this product in stock's store")
	}

	return convertProductInStockToGraphQL(productInStock, r.DB), nil
}

// StockSupplies is the resolver for the stockSupplies field.
func (r *queryResolver) StockSupplies(ctx context.Context, storeID *string, productID *string, providerID *string) ([]*model.StockSupply, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	var supplies []*database.StockSupply
	if productID != nil && *productID != "" {
		supplies, err = r.DB.FindStockSuppliesByProductID(*productID, storeIDs)
	} else if providerID != nil && *providerID != "" {
		supplies, err = r.DB.FindStockSuppliesByProviderID(*providerID, storeIDs)
	} else {
		supplies, err = r.DB.FindStockSuppliesByStoreIDs(storeIDs)
	}
	if err != nil {
		return nil, err
	}

	var result []*model.StockSupply
	for _, supply := range supplies {
		result = append(result, convertStockSupplyToGraphQL(supply, r.DB))
	}

	return result, nil
}

// StockSupply is the resolver for the stockSupply field.
func (r *queryResolver) StockSupply(ctx context.Context, id string) (*model.StockSupply, error) {
	if err := validators.ValidateObjectID(id, "Stock Supply ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	supply, err := r.DB.FindStockSupplyByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, supply.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this stock supply's store")
	}

	return convertStockSupplyToGraphQL(supply, r.DB), nil
}

// ProviderDebts is the resolver for the providerDebts field.
func (r *queryResolver) ProviderDebts(ctx context.Context, storeID *string, providerID *string, status *string) ([]*model.ProviderDebt, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	var debts []*database.ProviderDebt
	if providerID != nil && *providerID != "" {
		storeIDStr := storeID
		debts, err = r.DB.GetProviderDebtsByProviderID(*providerID, storeIDStr)
	} else {
		debts, err = r.DB.GetStoreProviderDebts(storeIDs, status)
	}
	if err != nil {
		return nil, err
	}

	var result []*model.ProviderDebt
	for _, debt := range debts {
		result = append(result, convertProviderDebtToGraphQL(debt, r.DB))
	}

	return result, nil
}

// ProviderDebt is the resolver for the providerDebt field.
func (r *queryResolver) ProviderDebt(ctx context.Context, id string) (*model.ProviderDebt, error) {
	if err := validators.ValidateObjectID(id, "Provider Debt ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	debt, err := r.DB.GetProviderDebtByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, debt.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this provider debt's store")
	}

	return convertProviderDebtToGraphQL(debt, r.DB), nil
}

// Clients is the resolver for the clients field.
func (r *queryResolver) Clients(ctx context.Context, storeID *string) ([]*model.Client, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	clients, err := r.DB.FindClientsByStoreIDs(storeIDs)
	if err != nil {
		return nil, err
	}

	var result []*model.Client
	for _, client := range clients {
		result = append(result, convertClientToGraphQL(client, r.DB))
	}

	return result, nil
}

// Client is the resolver for the client field.
func (r *queryResolver) Client(ctx context.Context, id string) (*model.Client, error) {
	if err := validators.ValidateObjectID(id, "Client ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	client, err := r.DB.FindClientByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, client.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this client's store")
	}

	return convertClientToGraphQL(client, r.DB), nil
}

// Providers is the resolver for the providers field.
func (r *queryResolver) Providers(ctx context.Context, storeID *string) ([]*model.Provider, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	providers, err := r.DB.FindProvidersByStoreIDs(storeIDs)
	if err != nil {
		return nil, err
	}

	var result []*model.Provider
	for _, provider := range providers {
		result = append(result, convertProviderToGraphQL(provider, r.DB))
	}

	return result, nil
}

// Provider is the resolver for the provider field.
func (r *queryResolver) Provider(ctx context.Context, id string) (*model.Provider, error) {
	if err := validators.ValidateObjectID(id, "Provider ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	provider, err := r.DB.FindProviderByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, provider.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this provider's store")
	}

	return convertProviderToGraphQL(provider, r.DB), nil
}

// Factures is the resolver for the factures field.
func (r *queryResolver) Factures(ctx context.Context, storeID *string) ([]*model.Facture, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	factures, err := r.DB.FindFacturesByStoreIDs(storeIDs)
	if err != nil {
		return nil, err
	}

	var result []*model.Facture
	for _, facture := range factures {
		result = append(result, convertFactureToGraphQL(facture, r.DB))
	}

	return result, nil
}

// Facture is the resolver for the facture field.
func (r *queryResolver) Facture(ctx context.Context, id string) (*model.Facture, error) {
	if err := validators.ValidateObjectID(id, "Facture ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	facture, err := r.DB.FindFactureByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, facture.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this facture's store")
	}

	return convertFactureToGraphQL(facture, r.DB), nil
}

// RapportStore is the resolver for the rapportStore field.
func (r *queryResolver) RapportStore(ctx context.Context, storeID *string) ([]*model.RapportStore, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	rapports, err := r.DB.FindRapportsByStoreIDs(storeIDs)
	if err != nil {
		return nil, err
	}

	var result []*model.RapportStore
	for _, rapport := range rapports {
		result = append(result, convertRapportStoreToGraphQL(rapport, r.DB))
	}

	return result, nil
}

// RapportStoreByID is the resolver for the rapportStoreById field.
func (r *queryResolver) RapportStoreByID(ctx context.Context, id string) (*model.RapportStore, error) {
	if err := validators.ValidateObjectID(id, "RapportStore ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	rapport, err := r.DB.FindRapportStoreByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, rapport.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this rapport's store")
	}

	return convertRapportStoreToGraphQL(rapport, r.DB), nil
}

// Caisse is the resolver for the caisse field.
func (r *queryResolver) Caisse(ctx context.Context, storeID *string, currency *string, period *string) (*model.Caisse, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	var storeIDStr *string

	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		// Verify store access
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
		storeIDStr = storeID
	} else {
		// Get accessible stores
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return nil, gqlerror.Errorf("No accessible stores")
	}

	var caisse *database.Caisse
	if storeIDStr != nil {
		caisse, err = r.DB.FindCaisse(storeIDStr, currency, period)
	} else {
		caisse, err = r.DB.FindCaisseByStoreIDs(storeIDs, currency, period)
	}
	if err != nil {
		return nil, err
	}

	return convertCaisseToGraphQL(caisse, r.DB), nil
}

// CaisseTransactions is the resolver for the caisseTransactions field.
func (r *queryResolver) CaisseTransactions(ctx context.Context, storeID *string, currency *string, period *string, limit *int) ([]*model.CaisseTransaction, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		// Verify store access
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		// Get accessible stores
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return nil, gqlerror.Errorf("No accessible stores")
	}

	transactions, err := r.DB.FindTransByStoreIDs(storeIDs, currency, period, limit)
	if err != nil {
		return nil, err
	}

	var result []*model.CaisseTransaction
	for _, trans := range transactions {
		result = append(result, convertCaisseTransactionToGraphQL(trans, r.DB))
	}

	return result, nil
}

// CaisseTransaction is the resolver for the caisseTransaction field.
func (r *queryResolver) CaisseTransaction(ctx context.Context, id string) (*model.CaisseTransaction, error) {
	if err := validators.ValidateObjectID(id, "Transaction ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	trans, err := r.DB.FindTransByID(id)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, trans.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this transaction's store")
	}

	return convertCaisseTransactionToGraphQL(trans, r.DB), nil
}

// CaisseRapport is the resolver for the caisseRapport field.
func (r *queryResolver) CaisseRapport(ctx context.Context, storeID *string, currency *string, period *string, startDate *string, endDate *string) (*model.CaisseRapport, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDStr *string
	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		// Verify store access
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		storeIDStr = storeID
	} else {
		// Get accessible stores - for multiple stores, we'll use the first one or all
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		if len(accessibleStoreIDs) > 0 {
			storeIDStr = &accessibleStoreIDs[0]
		}
	}

	rapport, err := r.DB.FindCaisseRapport(storeIDStr, currency, period, startDate, endDate)
	if err != nil {
		return nil, err
	}

	return convertCaisseRapportToGraphQL(rapport, r.DB), nil
}

// Sales is the resolver for the sales field.
func (r *queryResolver) Sales(ctx context.Context, storeID *string, limit *int, offset *int, period *string, startDate *string, endDate *string, currency *string) ([]*model.Sale, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID

	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		// Verify store access
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		// Get accessible stores
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return []*model.Sale{}, nil
	}

	sales, err := r.DB.FindSalesByStoreIDsWithFilters(storeIDs, limit, offset, period, startDate, endDate, currency)
	if err != nil {
		return nil, err
	}

	var result []*model.Sale
	for _, sale := range sales {
		result = append(result, convertSaleToGraphQL(sale, r.DB))
	}

	return result, nil
}

// SalesList is the resolver for the salesList field.
func (r *queryResolver) SalesList(ctx context.Context, storeID *string, limit *int, offset *int, period *string, startDate *string, endDate *string, currency *string) ([]*model.SaleList, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID

	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		// Verify store access
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		// Get accessible stores
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return []*model.SaleList{}, nil
	}

	// Use optimized function with projection for list view (lazy loading)
	// This function only retrieves necessary fields, reducing data transfer
	sales, err := r.DB.FindSalesListByStoreIDsWithFilters(storeIDs, limit, offset, period, startDate, endDate, currency)
	if err != nil {
		return nil, err
	}

	var result []*model.SaleList
	for _, sale := range sales {
		result = append(result, convertSaleListToGraphQL(sale, r.DB))
	}

	return result, nil
}

// SalesCount is the resolver for the salesCount field.
func (r *queryResolver) SalesCount(ctx context.Context, storeID *string, period *string, startDate *string, endDate *string, currency *string) (int, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return 0, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID

	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return 0, err
		}
		// Verify store access
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return 0, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		// Get accessible stores
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return 0, nil
	}

	count, err := r.DB.CountSalesByStoreIDs(storeIDs, period, startDate, endDate, currency)
	if err != nil {
		return 0, err
	}

	return int(count), nil
}

// SalesStats is the resolver for the salesStats field.
func (r *queryResolver) SalesStats(ctx context.Context, storeID *string, period *string, startDate *string, endDate *string, currency *string) (*model.SalesStats, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID

	if storeID != nil {
		if err := validators.ValidateObjectID(*storeID, "Store ID"); err != nil {
			return nil, err
		}
		// Verify store access
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		// Get accessible stores
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return &model.SalesStats{
			TotalSales:    0,
			TotalRevenue:  0,
			TotalItems:    0,
			AverageSale:   0,
			TotalBenefice: 0,
		}, nil
	}

	stats, err := r.DB.GetSalesStatsByStoreIDs(storeIDs, period, startDate, endDate, currency)
	if err != nil {
		return nil, err
	}

	// Calculate benefice using optimized aggregation pipeline (avoids N+1 queries)
	totalBenefice, err := r.DB.CalculateTotalBeneficeByStoreIDs(storeIDs, period, startDate, endDate, currency)
	if err != nil {
		// If benefice calculation fails, set to 0 but don't fail the entire query
		totalBenefice = 0
	}

	return &model.SalesStats{
		TotalSales:    int(stats.TotalSales),
		TotalRevenue:  stats.TotalRevenue,
		TotalItems:    stats.TotalItems,
		AverageSale:   stats.AverageSale,
		TotalBenefice: totalBenefice,
	}, nil
}

// Sale is the resolver for the sale field.
func (r *queryResolver) Sale(ctx context.Context, id string) (*model.Sale, error) {
	if err := validators.ValidateObjectID(id, "Sale ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	sale, err := r.DB.FindSaleByID(id)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, sale.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this sale's store")
	}

	return convertSaleToGraphQL(sale, r.DB), nil
}

// Debts is the resolver for the debts field.
func (r *queryResolver) Debts(ctx context.Context, storeID *string, status *string) ([]*model.Debt, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return []*model.Debt{}, nil
	}

	debts, err := r.DB.GetStoreDebts(storeIDs, status)
	if err != nil {
		return nil, err
	}

	var result []*model.Debt
	for _, debt := range debts {
		result = append(result, convertDebtToGraphQL(debt, r.DB))
	}

	return result, nil
}

// Debt is the resolver for the debt field.
func (r *queryResolver) Debt(ctx context.Context, id string) (*model.Debt, error) {
	if err := validators.ValidateObjectID(id, "Debt ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	debt, err := r.DB.GetDebtByID(id)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, debt.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this debt's store")
	}

	return convertDebtToGraphQL(debt, r.DB), nil
}

// ClientDebts is the resolver for the clientDebts field.
func (r *queryResolver) ClientDebts(ctx context.Context, clientID string, storeID *string) ([]*model.Debt, error) {
	if err := validators.ValidateObjectID(clientID, "Client ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Verify client exists and access
	client, err := r.DB.FindClientByID(clientID)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, client.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this client's store")
	}

	// If storeID is provided, verify it matches client's store
	if storeID != nil && *storeID != client.StoreID.Hex() {
		return nil, gqlerror.Errorf("Client does not belong to the specified store")
	}

	debts, err := r.DB.GetClientDebts(clientID, storeID)
	if err != nil {
		return nil, err
	}

	var result []*model.Debt
	for _, debt := range debts {
		result = append(result, convertDebtToGraphQL(debt, r.DB))
	}

	return result, nil
}

// Inventories is the resolver for the inventories field.
func (r *queryResolver) Inventories(ctx context.Context, storeID *string, status *string) ([]*model.Inventory, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	var storeIDs []primitive.ObjectID
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return []*model.Inventory{}, nil
	}

	inventories, err := r.DB.GetInventoriesByStoreIDs(storeIDs, status)
	if err != nil {
		return nil, err
	}

	var result []*model.Inventory
	for _, inventory := range inventories {
		result = append(result, convertInventoryToGraphQL(inventory, r.DB))
	}

	return result, nil
}

// Inventory is the resolver for the inventory field.
func (r *queryResolver) Inventory(ctx context.Context, id string) (*model.Inventory, error) {
	if err := validators.ValidateObjectID(id, "Inventory ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	inventory, err := r.DB.GetInventoryByID(id)
	if err != nil {
		return nil, err
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, inventory.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this inventory's store")
	}

	return convertInventoryToGraphQL(inventory, r.DB), nil
}

// ActiveInventory is the resolver for the activeInventory field.
func (r *queryResolver) ActiveInventory(ctx context.Context, storeID string) (*model.Inventory, error) {
	if err := validators.ValidateObjectID(storeID, "Store ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Verify store access
	hasAccess, err := r.HasStoreAccess(ctx, storeID)
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this store")
	}

	activeInventory, err := r.DB.GetActiveInventory(storeID)
	if err != nil {
		return nil, err
	}

	if activeInventory == nil {
		return nil, nil // No active inventory
	}

	return convertInventoryToGraphQL(activeInventory, r.DB), nil
}

// StockReport is the resolver for the stockReport field.
func (r *queryResolver) StockReport(ctx context.Context, storeID *string, productID *string, currency *string, period *string, startDate *string, endDate *string, typeArg *model.StockMovementType) (*model.StockReport, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Verify store access if storeID is provided
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
	} else {
		// If no storeID provided, use first accessible store
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		if len(accessibleStoreIDs) == 0 {
			return nil, gqlerror.Errorf("No accessible stores")
		}
		storeID = &accessibleStoreIDs[0]
	}

	// Convert movement type
	var movementType *string
	if typeArg != nil {
		typeStr := string(*typeArg)
		movementType = &typeStr
	}

	// Get stock report
	report, err := r.DB.GetStockReport(storeID, productID, currency, period, startDate, endDate, movementType)
	if err != nil {
		return nil, err
	}

	return convertStockReportToGraphQL(report, r.DB), nil
}

// StockMovements is the resolver for the stockMovements field.
func (r *queryResolver) StockMovements(ctx context.Context, storeID *string, productID *string, typeArg *model.StockMovementType, startDate *string, endDate *string, limit *int, offset *int) ([]*model.StockMovement, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Determine store IDs
	var storeIDs []primitive.ObjectID
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
		id, _ := primitive.ObjectIDFromHex(*storeID)
		storeIDs = []primitive.ObjectID{id}
	} else {
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		for _, id := range accessibleStoreIDs {
			objectID, _ := primitive.ObjectIDFromHex(id)
			storeIDs = append(storeIDs, objectID)
		}
	}

	if len(storeIDs) == 0 {
		return []*model.StockMovement{}, nil
	}

	// Convert movement type
	var movementType *string
	if typeArg != nil {
		typeStr := string(*typeArg)
		movementType = &typeStr
	}

	// Parse dates
	var startDatePtr *time.Time
	var endDatePtr *time.Time
	if startDate != nil {
		parsed, err := time.Parse(time.RFC3339, *startDate)
		if err != nil {
			parsed, err = time.Parse("2006-01-02", *startDate)
			if err != nil {
				return nil, gqlerror.Errorf("Invalid start date format")
			}
		}
		startDatePtr = &parsed
	}
	if endDate != nil {
		parsed, err := time.Parse(time.RFC3339, *endDate)
		if err != nil {
			parsed, err = time.Parse("2006-01-02", *endDate)
			if err != nil {
				return nil, gqlerror.Errorf("Invalid end date format")
			}
		}
		// Set to end of day
		parsed = time.Date(parsed.Year(), parsed.Month(), parsed.Day(), 23, 59, 59, 999999999, parsed.Location())
		endDatePtr = &parsed
	}

	// Get movements
	movements, err := r.DB.FindStockMovements(storeIDs, productID, movementType, startDatePtr, endDatePtr, nil, limit, offset)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	result := make([]*model.StockMovement, len(movements))
	for i, movement := range movements {
		result[i] = convertStockMovementToGraphQL(movement, r.DB)
	}

	return result, nil
}

// StockStats is the resolver for the stockStats field.
func (r *queryResolver) StockStats(ctx context.Context, storeID *string, productID *string, period *string, startDate *string, endDate *string) (*model.StockStats, error) {
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	// Verify store access if storeID is provided
	if storeID != nil {
		hasAccess, err := r.HasStoreAccess(ctx, *storeID)
		if err != nil || !hasAccess {
			return nil, gqlerror.Errorf("You don't have access to this store")
		}
	} else {
		// If no storeID provided, use first accessible store
		accessibleStoreIDs, _ := r.GetAccessibleStoreIDs(ctx)
		if len(accessibleStoreIDs) == 0 {
			return nil, gqlerror.Errorf("No accessible stores")
		}
		storeID = &accessibleStoreIDs[0]
	}

	// Get stock stats
	stats, err := r.DB.GetStockStats(storeID, productID, period, startDate, endDate)
	if err != nil {
		return nil, err
	}

	return convertStockStatsToGraphQL(stats, r.DB), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func stringPtr(s string) *string {
	return &s
}
func (r *queryResolver) RapportStoreById(ctx context.Context, id string) (*model.RapportStore, error) {
	if err := validators.ValidateObjectID(id, "RapportStore ID"); err != nil {
		return nil, err
	}
	currentUser, err := r.GetUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, gqlerror.Errorf("Unauthorized")
	}

	rapport, err := r.DB.FindRapportStoreByID(id)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.HasStoreAccess(ctx, rapport.StoreID.Hex())
	if err != nil || !hasAccess {
		return nil, gqlerror.Errorf("You don't have access to this rapport's store")
	}

	return convertRapportStoreToGraphQL(rapport, r.DB), nil
}
