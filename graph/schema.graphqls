# GraphQL schema for RangoApp Multi-Store Management System

directive @auth on FIELD | FIELD_DEFINITION

scalar Date

# ============ TYPES ============

type User {
  id: ID!
  uid: String!
  name: String!
  phone: String!
  role: String! # Admin, User, etc.
  isBlocked: Boolean!
  companyId: String!
  storeIds: [String!]! # Liste des stores pour Admin, un seul store pour User
  assignedStoreId: String # Store assigné (pour User non-admin)
  createdAt: String!
  updatedAt: String!
}

type ExchangeRate {
  fromCurrency: String!
  toCurrency: String!
  rate: Float!
  isDefault: Boolean! # Indique si c'est le taux par défaut (non modifiable facilement)
  updatedAt: String!
  updatedBy: String! # ID de l'utilisateur qui a modifié le taux
}

type Company {
  id: ID!
  name: String!
  address: String!
  phone: String!
  email: String
  description: String!
  type: String!
  logo: String
  rccm: String
  idNat: String
  idCommerce: String
  stores: [Store!]! # Liste des boutiques de l'entreprise
  subscription: CompanySubscription! # Abonnement de l'entreprise
  exchangeRates: [ExchangeRate!]! # Taux de change configurés pour l'entreprise
  createdAt: String!
  updatedAt: String!
}

type Store {
  id: ID!
  name: String!
  address: String!
  phone: String!
  companyId: String!
  company: Company!
  defaultCurrency: String! # Currency par défaut de la boutique (ex: "USD", "CDF")
  supportedCurrencies: [String!]! # Liste des currencies supportées par la boutique
  createdAt: String!
  updatedAt: String!
}

type Product {
  id: ID!
  name: String!
  mark: String!
  storeId: String!
  store: Store!
  createdAt: String!
  updatedAt: String!
}

type ProductInStock {
  id: ID!
  productId: String!
  product: Product! # Référence au produit template
  priceVente: Float!
  priceAchat: Float!
  currency: String! # Currency du produit (USD, EUR, CDF)
  stock: Float!
  storeId: String!
  store: Store!
  providerId: String! # ID du fournisseur (obligatoire lors de l'approvisionnement)
  provider: Provider! # Fournisseur du produit
  createdAt: String!
  updatedAt: String!
}

type Client {
  id: ID!
  name: String!
  phone: String!
  storeId: String!
  store: Store!
  creditLimit: Float! # Limite de crédit autorisée (0 = pas de crédit)
  currentDebt: Float! # Dette actuelle (somme des dettes impayées)
  availableCredit: Float! # Crédit disponible (creditLimit - currentDebt)
  createdAt: String!
  updatedAt: String!
}

type Provider {
  id: ID!
  name: String!
  phone: String!
  address: String!
  storeId: String!
  store: Store!
  createdAt: String!
  updatedAt: String!
}

type Facture {
  id: ID!
  factureNumber: String!
  products: [FactureProduct!]!
  quantity: Int!
  date: String!
  price: Float!
  currency: String!
  client: Client!
  storeId: String!
  store: Store!
  createdAt: String!
  updatedAt: String!
}

type FactureProduct {
  productId: String!
  product: Product!
  quantity: Int!
  price: Float!
}

type RapportStore {
  id: ID!
  type: String! # "entree" ou "sortie"
  product: Product!
  quantity: Float!
  date: String!
  storeId: String!
  store: Store!
  createdAt: String!
  updatedAt: String!
}

type AuthResponse {
  accessToken: String!
  refreshToken: String!
  user: User!
}

type CompanySubscription {
  id: ID!
  companyId: String!
  plan: String! # "trial", "starter", "business", "enterprise"
  status: String! # "active", "expired", "cancelled", "suspended"
  trialStartDate: String!
  trialEndDate: String!
  subscriptionStartDate: String
  subscriptionEndDate: String
  paymentMethod: String
  paymentId: String
  maxStores: Int!
  maxUsers: Int!
  daysRemaining: Int! # Jours restants dans l'essai ou l'abonnement
  isTrialExpired: Boolean!
  createdAt: String!
  updatedAt: String!
}

type SubscriptionStatus {
  isValid: Boolean!
  message: String
  subscription: CompanySubscription
}

type SubscriptionPlan {
  id: ID!
  name: String!
  price: Float!
  currency: String!  # "USD", "EUR", "CDF", etc.
  billingPeriod: String!  # "monthly", "yearly"
  description: String!
  features: [String!]!
  maxStores: Int  # null = illimité
  maxUsers: Int   # null = illimité
  isActive: Boolean!
  createdAt: String!
  updatedAt: String!
}

type CaisseTransaction {
  id: ID!
  amount: Float!
  operation: String! # "Entree" or "Sortie"
  description: String!
  currency: String! # "USD", "EUR" or "CDF"
  storeId: String!
  store: Store!
  date: String!
  createdAt: String!
  updatedAt: String!
}

type Caisse {
  currentBalance: Float!
  in: Float!
  out: Float!
  totalBenefice: Float! # Total profit from sales in the period
  currency: String! # "USD", "EUR" or "CDF"
  storeId: String
  store: Store
}

type CaisseRapport {
  storeId: String
  store: Store
  currency: String! # "USD", "EUR" or "CDF"
  period: String! # "jour", "semaine", "mois", "annee" ou "all"
  startDate: String!
  endDate: String!
  totalEntrees: Float!
  totalSorties: Float!
  totalBenefice: Float! # Total profit from sales in the period
  soldeInitial: Float! # Solde au début de la période
  soldeFinal: Float! # Solde à la fin de la période (soldeInitial + totalEntrees - totalSorties)
  nombreTransactions: Int!
  transactions: [CaisseTransaction!]! # Liste détaillée des transactions
  resumeParJour: [CaisseResumeJour!] # Résumé par jour (si période > jour)
}

type CaisseResumeJour {
  date: String!
  entrees: Float!
  sorties: Float!
  benefice: Float! # Profit from sales for this day
  solde: Float!
  nombreTransactions: Int!
}

type Sale {
  id: ID!
  basket: [SaleProduct!]!
  priceToPay: Float!
  pricePayed: Float!
  change: Float! # Calculated: pricePayed - priceToPay
  benefice: Float! # Calculated: sum of (price - priceAchat) * quantity for each product
  currency: String! # "USD", "EUR" or "CDF"
  client: Client # Optional: client may not be specified for walk-in sales
  operator: User! # User who made the sale
  storeId: String!
  store: Store!
  paymentType: String! # "cash", "debt", "advance"
  amountDue: Float! # Montant dû (dette restante)
  debtStatus: String! # "paid", "partial", "unpaid", "none"
  debtId: String # ID de la dette si applicable
  debt: Debt # Dette associée si applicable
  date: String!
  createdAt: String!
  updatedAt: String!
}

type SaleList {
  id: ID!
  date: String!
  createdAt: String!
  priceToPay: Float!
  pricePayed: Float!
  change: Float! # Calculated: pricePayed - priceToPay
  currency: String!
  client: Client # Optional: client may not be specified for walk-in sales
  basketCount: Int! # Number of different products in basket
  totalItems: Float! # Total quantity of all items
  storeId: String!
  paymentType: String! # "cash", "debt", "advance"
  amountDue: Float! # Montant dû (dette restante)
  debtStatus: String! # "paid", "partial", "unpaid", "none"
}

type Debt {
  id: ID!
  saleId: String!
  sale: Sale! # Vente associée
  clientId: String!
  client: Client! # Client qui doit
  storeId: String!
  store: Store!
  totalAmount: Float! # Montant total de la vente
  amountPaid: Float! # Montant déjà payé
  amountDue: Float! # Montant restant à payer
  currency: String! # "USD", "EUR" or "CDF"
  status: String! # "paid", "partial", "unpaid"
  paymentType: String! # "cash", "debt", "advance"
  payments: [DebtPayment!]! # Historique des paiements
  createdAt: String!
  updatedAt: String!
  paidAt: String # Date de paiement complet (si status = "paid")
}

type DebtPayment {
  id: ID!
  debtId: String!
  debt: Debt! # Dette associée
  amount: Float!
  currency: String! # "USD", "EUR" or "CDF"
  operatorId: String!
  operator: User! # Utilisateur qui a enregistré le paiement
  storeId: String!
  store: Store!
  description: String!
  createdAt: String!
}

type ProviderDebt {
  id: ID!
  supplyId: String! # ID de l'approvisionnement associé
  supply: StockSupply! # Approvisionnement associé
  providerId: String!
  provider: Provider! # Fournisseur à qui on doit
  storeId: String!
  store: Store!
  totalAmount: Float! # Montant total de l'approvisionnement
  amountPaid: Float! # Montant déjà payé
  amountDue: Float! # Montant restant à payer
  currency: String! # "USD", "EUR" or "CDF"
  status: String! # "paid", "partial", "unpaid"
  payments: [ProviderDebtPayment!]! # Historique des paiements
  createdAt: String!
  updatedAt: String!
  paidAt: String # Date de paiement complet (si status = "paid")
}

type ProviderDebtPayment {
  id: ID!
  providerDebtId: String!
  providerDebt: ProviderDebt! # Dette associée
  amount: Float!
  currency: String! # "USD", "EUR" or "CDF"
  operatorId: String!
  operator: User! # Utilisateur qui a enregistré le paiement
  storeId: String!
  store: Store!
  description: String!
  createdAt: String!
}

type StockSupply {
  id: ID!
  productId: String!
  product: Product! # Produit template
  productInStockId: String!
  productInStock: ProductInStock! # Produit en stock créé
  quantity: Float!
  priceAchat: Float!
  priceVente: Float!
  currency: String!
  providerId: String!
  provider: Provider!
  storeId: String!
  store: Store!
  operatorId: String!
  operator: User! # Utilisateur qui a fait l'approvisionnement
  paymentType: String! # "cash" ou "debt"
  providerDebtId: String # ID de la dette si paymentType = "debt"
  providerDebt: ProviderDebt # Dette associée si paymentType = "debt"
  date: String!
  createdAt: String!
  updatedAt: String!
}

type SalesStats {
  totalSales: Int! # Total number of sales
  totalRevenue: Float! # Total revenue (sum of pricePayed)
  totalItems: Float! # Total quantity of items sold
  averageSale: Float! # Average sale amount
  totalBenefice: Float! # Total profit (calculated separately)
}

type SaleProduct {
  productInStockId: String!
  productInStock: ProductInStock!
  quantity: Float!
  price: Float!
}

type Inventory {
  id: ID!
  storeId: String!
  store: Store!
  operatorId: String!
  operator: User! # Utilisateur qui a créé l'inventaire
  status: String! # "draft", "in_progress", "completed", "cancelled"
  startDate: String! # Date de début de l'inventaire
  endDate: String # Date de fin de l'inventaire (si status = "completed")
  description: String! # Description de l'inventaire
  items: [InventoryItem!]! # Liste des produits inventoriés
  totalItems: Int! # Nombre total de produits inventoriés
  totalValue: Float! # Valeur totale de l'inventaire (en prix de vente)
  createdAt: String!
  updatedAt: String!
}

type InventoryItem {
  productId: String!
  product: Product! # Produit associé
  productName: String! # Nom du produit au moment de l'inventaire (snapshot)
  systemQuantity: Float! # Quantité dans le système
  physicalQuantity: Float! # Quantité physique comptée
  difference: Float! # Différence (physicalQuantity - systemQuantity)
  unitPrice: Float! # Prix unitaire au moment de l'inventaire (prix de vente)
  totalValue: Float! # Valeur totale (physicalQuantity * unitPrice)
  reason: String # Raison de l'écart (vol, casse, erreur, etc.)
  countedBy: String! # ID de la personne qui a compté
  countedByUser: User! # Utilisateur qui a compté
  countedAt: String! # Date et heure du comptage
}

type StockMovement {
  id: ID!
  productId: ID!
  product: Product!
  storeId: ID!
  store: Store!
  type: StockMovementType! # "ENTREE" | "SORTIE" | "AJUSTEMENT"
  quantity: Float!
  unitPrice: Float!
  totalValue: Float!
  currency: String!
  reason: String
  reference: String # Référence à une vente, achat, inventaire, etc.
  referenceType: String # "SALE", "PURCHASE", "INVENTORY", "ADJUSTMENT", "TRANSFER"
  referenceId: ID
  operatorId: ID!
  operator: User!
  createdAt: String!
  updatedAt: String!
}

enum StockMovementType {
  ENTREE
  SORTIE
  AJUSTEMENT
}

type StockReport {
  storeId: ID!
  store: Store!
  currency: String!
  period: String! # "day", "week", "month", "year", "custom"
  startDate: String!
  endDate: String!
  
  # Totaux généraux
  totalEntrees: Float!
  totalSorties: Float!
  totalAjustements: Float!
  soldeInitial: Float!
  soldeFinal: Float!
  nombreMouvements: Int!
  
  # Détails par produit
  mouvementsParProduit: [StockMovementByProduct!]!
  
  # Résumé par jour
  resumeParJour: [StockReportResumeJour!]!
  
  # Liste complète des mouvements
  mouvements: [StockMovement!]!
}

type StockMovementByProduct {
  productId: ID!
  product: Product!
  totalEntrees: Float!
  totalSorties: Float!
  totalAjustements: Float!
  soldeInitial: Float!
  soldeFinal: Float!
  nombreMouvements: Int!
  valeurTotaleEntrees: Float!
  valeurTotaleSorties: Float!
}

type StockReportResumeJour {
  date: String!
  entrees: Float!
  sorties: Float!
  ajustements: Float!
  solde: Float!
  nombreMouvements: Int!
  valeurTotaleEntrees: Float!
  valeurTotaleSorties: Float!
}

type StockStats {
  totalProducts: Int!
  totalValue: Float!
  productsLowStock: Int! # Produits en stock faible (< seuil)
  productsOutOfStock: Int! # Produits en rupture
  totalEntrees: Float!
  totalSorties: Float!
  topProductsByMovements: [ProductMovementStats!]!
}

type ProductMovementStats {
  product: Product!
  totalEntrees: Float!
  totalSorties: Float!
  nombreMouvements: Int!
}

# ============ INPUTS ============

input RegisterInput {
  name: String!
  phone: String!
  password: String!
}

input CreateCompanyInput {
  name: String!
  address: String!
  phone: String!
  email: String
  description: String!
  type: String!
  logo: String
  rccm: String
  idNat: String
  idCommerce: String
}

input CreateUserInput {
  name: String!
  phone: String!
  password: String!
  role: String! # "Admin" ou "User"
  storeId: String # Optionnel: si role="User", assigner directement à un store
}

input UpdateUserInput {
  name: String
  phone: String
  role: String
  storeId: String # Pour changer l'assignation de store (si role="User")
}

input ChangePasswordInput {
  currentPassword: String!
  newPassword: String!
}

input ExchangeRateInput {
  fromCurrency: String!
  toCurrency: String!
  rate: Float!
}

input UpdateCompanyInput {
  name: String
  address: String
  phone: String
  email: String
  description: String
  type: String
  logo: String
  rccm: String
  idNat: String
  idCommerce: String
}

input CreateStoreInput {
  name: String!
  address: String!
  phone: String!
  defaultCurrency: String # Currency par défaut (optionnel, défaut: "USD")
  supportedCurrencies: [String!] # Liste des currencies supportées (optionnel, si non fourni, utilise defaultCurrency)
}

input UpdateStoreInput {
  name: String
  address: String
  phone: String
  defaultCurrency: String # Currency par défaut
  supportedCurrencies: [String!] # Liste des currencies supportées (doit inclure defaultCurrency)
}

input CreateProductInput {
  name: String!
  mark: String!
  storeId: String! # Store auquel appartient le produit
}

input UpdateProductInput {
  name: String
  mark: String
}

input StockSupplyInput {
  productId: String! # ID du produit template
  quantity: Float!
  priceAchat: Float!
  priceVente: Float!
  currency: String # Optional: si non fourni, utilise la currency par défaut de la boutique
  storeId: String!
  providerId: String! # ID du fournisseur (obligatoire)
  paymentType: String! # "cash" ou "debt"
  amountPaid: Float # Montant payé (obligatoire si paymentType = "debt", optionnel si "cash")
  date: String # Optional, defaults to now
}

input CreateClientInput {
  name: String!
  phone: String!
  storeId: String! # Store auquel appartient le client
  creditLimit: Float # Limite de crédit autorisée (optionnel, défaut: 0)
}

input UpdateClientInput {
  name: String
  phone: String
  creditLimit: Float # Modifier la limite de crédit
}

input CreateProviderInput {
  name: String!
  phone: String!
  address: String!
  storeId: String! # Store auquel appartient le fournisseur
}

input UpdateProviderInput {
  name: String
  phone: String
  address: String
}

input FactureProductInput {
  productId: String!
  quantity: Int!
  price: Float!
}

input CreateFactureInput {
  products: [FactureProductInput!]!
  clientId: String!
  storeId: String! # Store pour lequel la facture est créée
  quantity: Int!
  price: Float!
  currency: String # Optional: si non fourni, utilise la currency par défaut de la boutique
  date: String!
}

input UpdateFactureInput {
  products: [FactureProductInput!]
  clientId: String
  quantity: Int
  price: Float
  currency: String
  date: String
}

input CreateRapportStoreInput {
  productId: String!
  storeId: String! # Store pour lequel le rapport est créé
  quantity: Float!
  type: String! # "entree" ou "sortie"
  date: String!
}

input CreateCaisseTransactionInput {
  amount: Float!
  operation: String! # "Entree" or "Sortie"
  description: String!
  currency: String # Optional: si non fourni, utilise la currency par défaut de la boutique
  storeId: String!
  date: String
}

input SaleProductInput {
  productInStockId: String! # ID du produit en stock (ProductInStock)
  quantity: Float!
  price: Float!
}

input CreateSaleInput {
  basket: [SaleProductInput!]!
  priceToPay: Float!
  pricePayed: Float!
  clientId: String # Optional: client may not be specified for walk-in sales
  storeId: String!
  currency: String # Optional: si non fourni, utilise la currency par défaut de la boutique
  paymentType: String # Optional: "cash", "debt", "advance" (défaut: "cash")
  date: String # Optional, defaults to now
}

input CreateInventoryInput {
  storeId: String!
  description: String! # Description de l'inventaire
}

input AddInventoryItemInput {
  inventoryId: String!
  productId: String!
  physicalQuantity: Float! # Quantité physique comptée
  reason: String # Raison de l'écart (vol, casse, erreur, etc.)
}

# ============ QUERIES ============

type Query {
  # Auth
  me: User! @auth

  # Users
  users: [User!]! @auth
  user(id: ID!): User @auth
  
  # Company
  company: Company! @auth
  
  # Exchange Rates
  exchangeRates: [ExchangeRate!]! @auth # Récupère les taux de change de l'entreprise
  convertCurrency(amount: Float!, fromCurrency: String!, toCurrency: String!): Float! @auth # Convertit un montant d'une devise à une autre
  
  # Subscription
  subscription: CompanySubscription! @auth
  checkSubscriptionStatus: SubscriptionStatus! @auth
  
  # Subscription Plans
  subscriptionPlans: [SubscriptionPlan!]! # Public query, no auth required
  subscriptionPlan(id: ID!): SubscriptionPlan # Public query, no auth required
  
  # Stores
  stores: [Store!]! @auth
  store(id: ID!): Store @auth
  
  # Products (templates)
  products(storeId: String): [Product!]! @auth # Si storeId non fourni, retourne les produits des stores accessibles
  product(id: ID!): Product @auth
  
  # Products in Stock
  productsInStock(storeId: String, productId: String, providerId: String): [ProductInStock!]! @auth # Liste des produits en stock. Filtres optionnels
  productInStock(id: ID!): ProductInStock @auth
  
  # Stock Supplies
  stockSupplies(storeId: String, productId: String, providerId: String): [StockSupply!]! @auth # Historique des approvisionnements
  stockSupply(id: ID!): StockSupply @auth
  
  # Provider Debts
  providerDebts(storeId: String, providerId: String, status: String): [ProviderDebt!]! @auth # Liste des dettes envers les fournisseurs
  providerDebt(id: ID!): ProviderDebt @auth
  
  # Clients
  clients(storeId: String): [Client!]! @auth # Si storeId non fourni, retourne les clients des stores accessibles
  client(id: ID!): Client @auth
  
  # Providers
  providers(storeId: String): [Provider!]! @auth # Si storeId non fourni, retourne les fournisseurs des stores accessibles
  provider(id: ID!): Provider @auth
  
  # Factures
  factures(storeId: String): [Facture!]! @auth # Si storeId non fourni, retourne les factures des stores accessibles
  facture(id: ID!): Facture @auth

  # RapportStore
  rapportStore(storeId: String): [RapportStore!]! @auth # Si storeId non fourni, retourne les rapports des stores accessibles
  rapportStoreById(id: ID!): RapportStore @auth

  # Caisse
  caisse(storeId: String, currency: String, period: String): Caisse! @auth # period: "jour", "semaine", "mois", "annee" ou null pour tout
  caisseTransactions(storeId: String, currency: String, period: String, limit: Int): [CaisseTransaction!]! @auth
  caisseTransaction(id: ID!): CaisseTransaction @auth
  caisseRapport(storeId: String, currency: String, period: String, startDate: String, endDate: String): CaisseRapport! @auth # Rapport détaillé de la caisse avec entrées et sorties

  # Sales
  sales(
    storeId: String
    limit: Int
    offset: Int
    period: String
    startDate: String
    endDate: String
    currency: String
  ): [Sale!]! @auth # Si storeId non fourni, retourne les ventes des stores accessibles
  salesList(
    storeId: String
    limit: Int
    offset: Int
    period: String
    startDate: String
    endDate: String
    currency: String
  ): [SaleList!]! @auth # Version optimisée pour la liste (sans détails complets)
  salesCount(
    storeId: String
    period: String
    startDate: String
    endDate: String
    currency: String
  ): Int! @auth # Nombre total de ventes pour la pagination
  salesStats(
    storeId: String
    period: String
    startDate: String
    endDate: String
    currency: String
  ): SalesStats! @auth # Statistiques agrégées des ventes (utilise aggregation pipeline)
  sale(id: ID!): Sale @auth
  
  # Debts
  debts(storeId: String, status: String): [Debt!]! @auth # Liste des dettes (optionnel: filtrer par store et status)
  debt(id: ID!): Debt @auth # Détails d'une dette
  clientDebts(clientId: String!, storeId: String): [Debt!]! @auth # Dettes d'un client spécifique
  
  # Inventories
  inventories(storeId: String, status: String): [Inventory!]! @auth # Liste des inventaires (optionnel: filtrer par store et status)
  inventory(id: ID!): Inventory @auth # Détails d'un inventaire
  activeInventory(storeId: String!): Inventory @auth # Inventaire actif pour un store (draft ou in_progress)
  
  # Stock Reports
  stockReport(
    storeId: String
    productId: String
    currency: String
    period: String # "day", "week", "month", "year", "custom"
    startDate: String
    endDate: String
    type: StockMovementType # Filtrer par type de mouvement
  ): StockReport! @auth # Récupérer le rapport de stock
  
  # Récupérer l'historique des mouvements de stock
  stockMovements(
    storeId: String
    productId: String
    type: StockMovementType
    startDate: String
    endDate: String
    limit: Int
    offset: Int
  ): [StockMovement!]! @auth
  
  # Statistiques de stock
  stockStats(
    storeId: String
    productId: String
    period: String
    startDate: String
    endDate: String
  ): StockStats! @auth
}

# ============ MUTATIONS ============

type Mutation {
  # Auth
  login(phone: String!, password: String!): AuthResponse!
  register(input: RegisterInput!): AuthResponse!
  refreshToken(refreshToken: String!): AuthResponse!
  logout: Boolean! @auth
  
  # Users
  createUser(input: CreateUserInput!): User! @auth
  updateUser(id: ID!, input: UpdateUserInput!): User! @auth
  deleteUser(id: ID!): Boolean! @auth
  blockUser(id: ID!): User! @auth
  unblockUser(id: ID!): User! @auth
  assignUserToStore(userId: ID!, storeId: ID!): User! @auth # Assigner un utilisateur User à un store
  changePassword(input: ChangePasswordInput!): Boolean! @auth # Changer le mot de passe de l'utilisateur connecté
  
  # Company
  createCompany(input: CreateCompanyInput!): Company! @auth
  updateCompany(input: UpdateCompanyInput!): Company! @auth
  deleteCompany: Boolean! @auth
  
  # Exchange Rates
  updateExchangeRates(rates: [ExchangeRateInput!]!): Company! @auth # Met à jour les taux de change de l'entreprise

  # Stores
  createStore(input: CreateStoreInput!): Store! @auth
  updateStore(id: ID!, input: UpdateStoreInput!): Store! @auth
  deleteStore(id: ID!): Boolean! @auth

  # Products (templates)
  createProduct(input: CreateProductInput!): Product! @auth
  updateProduct(id: ID!, input: UpdateProductInput!): Product! @auth
  deleteProduct(id: ID!): Boolean! @auth
  
  # Stock Supply (Approvisionnement)
  supplyStock(input: StockSupplyInput!): StockSupply! @auth # Approvisionner un produit en stock

  # Clients
  createClient(input: CreateClientInput!): Client! @auth
  updateClient(id: ID!, input: UpdateClientInput!): Client! @auth
  deleteClient(id: ID!): Boolean! @auth
  updateClientCreditLimit(clientId: ID!, creditLimit: Float!): Client! @auth # Modifier la limite de crédit d'un client

  # Providers
  createProvider(input: CreateProviderInput!): Provider! @auth
  updateProvider(id: ID!, input: UpdateProviderInput!): Provider! @auth
  deleteProvider(id: ID!): Boolean! @auth
  
  # Factures
  createFacture(input: CreateFactureInput!): Facture! @auth
  updateFacture(id: ID!, input: UpdateFactureInput!): Facture! @auth
  deleteFacture(id: ID!): Boolean! @auth
  
  # RapportStore
  createRapportStore(input: CreateRapportStoreInput!): RapportStore! @auth
  deleteRapportStore(id: ID!): Boolean! @auth

  # Caisse
  createCaisseTransaction(input: CreateCaisseTransactionInput!): CaisseTransaction! @auth
  deleteCaisseTransaction(id: ID!): Boolean! @auth

  # Sales
  createSale(input: CreateSaleInput!): Sale! @auth
  deleteSale(id: ID!): Boolean! @auth
  createFactureFromSale(saleId: ID!): Facture! @auth # Generate a facture from a sale for printing
  
  # Debts
  payDebt(debtId: ID!, amount: Float!, description: String!): Debt! @auth # Payer une dette (partiellement ou totalement)
  
  # Provider Debts
  payProviderDebt(providerDebtId: ID!, amount: Float!, description: String!): ProviderDebt! @auth # Payer une dette envers un fournisseur
  
  # Inventories
  createInventory(input: CreateInventoryInput!): Inventory! @auth # Créer une nouvelle session d'inventaire
  addInventoryItem(input: AddInventoryItemInput!): Inventory! @auth # Ajouter ou mettre à jour un produit dans l'inventaire
  completeInventory(inventoryId: ID!, adjustStock: Boolean!): Inventory! @auth # Compléter l'inventaire (optionnel: ajuster le stock automatiquement)
  cancelInventory(inventoryId: ID!): Inventory! @auth # Annuler un inventaire
  
  # Subscription
  createSubscription(plan: String!, paymentMethod: String!, paymentId: String!): CompanySubscription! @auth
  upgradeSubscription(plan: String!, paymentMethod: String!, paymentId: String!): CompanySubscription! @auth
  cancelSubscription: Boolean! @auth
}
